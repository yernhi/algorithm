#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

typedef pair<int,int> pii;

const int MAXN = 100;
bool visited[MAXN][MAXN];
int dir[4][2] = {
    {1,0},{-1,0},{0,1},{0,-1}
};

int row_range ;
int col_range ;
void print_graph(vector<string> citymap){
    for(int i=0; i<citymap.size();i++){
        for(int j=0; j<citymap[0].size(); j++){
            cout<<citymap[i][j];
        }cout<<endl;
    }


}


int reach_count(int start_row, int start_col, vector<string> &citymap){
    queue< pii  > Q;
    Q.push( pii(start_row, start_col) );
    memset(visited,0,sizeof(visited));
    visited[start_row][start_col] = true;
    int row, col;
    int cnt = 0;

    while(!Q.empty()){
        pii cur = Q.front();
        Q.pop();
        int cur_row = cur.first;
        int cur_col = cur.second;
        for(int i=0; i<4; i++){
            int next_row = cur_row + dir[i][0]*2;
            int next_col = cur_col + dir[i][1]*2;
            int road_row = cur_row + dir[i][0];
            int road_col = cur_col + dir[i][1];
            /*
            cout<<"next_row next col are "<<next_row<<" "<<next_col<<" "<<citymap[next_row][next_col]<<endl;
            cout<<"road_row = "<<citymap[road_row][road_col]<<endl;
            cout<<"visited = "<<visited[next_row][next_col]<<endl;

            cout<<(next_row>=0 && next_row<row_range && next_col>=0 && next_col<col_range && citymap[next_row][next_col]=='+')<<endl;
            //&& ( citymap[road_row][road_col]=='|'  || citymap[road_row][road_col]=='-')  && visited[next_row][next_col]== false)<<endl;
            */
            if(next_row>=0 && next_row<row_range && next_col>=0 && next_col<col_range && citymap[next_row][next_col]=='+'&& ( citymap[road_row][road_col]=='|'  || citymap[road_row][road_col]=='-')  && visited[next_row][next_col]== false){ 
                    Q.push( pii( next_row, next_col) );
                    visited[next_row][next_col] = true;
                    cnt+=1;
            }
        }
    }
    return cnt;
}

bool deleted[MAXN][MAXN];

class SnowClearing {
    public:
        int unreachable(vector <string> citymap, int row, int column) {
            row_range = citymap.size();
            col_range = citymap[0].size();
            int initial_cnt = reach_count(2*row-1 -1, 2*column-1 -1, citymap);
            cout<<"initial count = "<<initial_cnt<<endl;
            int ans = 0;

            int start_row = 2*row-2;
            int start_col = 2*column-2;
            memset(deleted, 0, sizeof(deleted) );
            while(1){
                bool ok = false;
                for(int i=0; i<citymap.size(); i++){
                    for(int j=0; j<citymap[0].size(); j++){
                        if(citymap[i][j]=='+' && !(start_row==i && start_col ==j)){
                            int degree = 0;
                            int _row, _col;
                            for(int k=0; k<4; k++){
                                int pos_row = i+dir[k][0];
                                int pos_col = j+dir[k][1];
                                if(pos_row>=0 && pos_row<row_range && pos_col>=0 && pos_col<col_range && (citymap[pos_row][pos_col]=='|' || citymap[pos_row][pos_col]=='-')){
                                    char t = citymap[pos_row][pos_col];
                                    cout<<"before change "<<endl;
                                    //print_graph(citymap);
                                    //citymap[pos_row][pos_col] ='#';
                                    deleted[pos_row][pos_col] = true;
                                    cout<<"after change "<<endl;
                                    //print_graph(citymap);
                                    cout<<endl<<endl;
                                    degree += 1;
                                    _row = pos_row;
                                    _col = pos_col;
                                }
                            }
                            if(degree==1){
                                cout<<"at "<<i<<" "<<j<<" degree == 1"<<endl;
                                ok = true;
                                citymap[_row][_col] = '#';
                                ans++;
                            }
                        }
                    }
                }
                if(ok==false)break;
            }
            return ans;
        }
        
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, int p1, int p2, bool hasAnswer, int p3) {
    cout << "Test " << testNum << ": [" << "{";
    for (int i = 0; int(p0.size()) > i; ++i) {
        if (i > 0) {
            cout << ",";
        }
        cout << "\"" << p0[i] << "\"";
    }
    cout << "}" << "," << p1 << "," << p2;
    cout << "]" << endl;
    SnowClearing *obj;
    int answer;
    obj = new SnowClearing();
    clock_t startTime = clock();
    answer = obj->unreachable(p0, p1, p2);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer) {
        cout << "Desired answer:" << endl;
        cout << "\t" << p3 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer) {
        res = answer == p3;
    }
    if (!res) {
        cout << "DOESN'T MATCH!!!!" << endl;
    } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
        cout << "FAIL the timeout" << endl;
        res = false;
    } else if (hasAnswer) {
        cout << "Match :-)" << endl;
    } else {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main() {
    bool all_right;
    all_right = true;

    vector <string> p0;
    int p1;
    int p2;
    int p3;

    {
        // ----- test 0 -----
        string t0[] = {"+-+-+-+-+-+-+","| | | | | | |","+-+ +-+ +-+ +","|   |   |    ","+-+-+-+-+-+-+"};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        p1 = 2;
        p2 = 7;
        p3 = 2;
        all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }
    {
        // ----- test 1 -----
        string t0[] = {"+-+","| |","+ +"};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        p1 = 1;
        p2 = 1;
        p3 = 3;
        all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }
    {
        // ----- test 2 -----
        string t0[] = {"+-+-+","| | |","+-+ +"};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        p1 = 1;
        p2 = 3;
        p3 = 1;
        all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }
    {
        // ----- test 3 -----
        string t0[] = {"+-+-+","|   |","+-+-+"};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        p1 = 2;
        p2 = 2;
        p3 = 0;
        all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }

    {
        // ----- test 4 -----
        string t0[] = {"+ +-+ +-+-+ +-+-+ +-+-+-+-+-+-+-+-+-+-+ +-+-+-+ +","| |   | |     |   |   |         |     | |     | |","+ +-+-+-+ +-+-+-+ +-+ +-+-+-+-+ +-+-+-+ +-+ +-+-+","| | |       |   | |   |   |   |   |     | |   |  ","+ +-+-+ +-+-+ +-+-+-+-+-+-+-+ +-+ +-+ +-+ +-+ +-+","|     | | | | |   |             |     |   | |   |","+-+-+ +-+-+-+ +-+ +-+ + +-+-+-+-+-+ +-+-+ +-+-+-+","|       | |     |     |   |         |   | |     |","+-+-+-+ +-+-+-+-+-+-+-+-+-+-+ +-+ +-+ +-+-+-+-+-+","      |   | |     |   | |     | | |   | |       |","+ +-+-+-+-+ + +-+ +-+ +-+ +-+-+ +-+-+-+-+-+ +-+-+","| |   | |     |   |         |   | | |     |   | |","+-+-+-+-+-+ +-+-+ +-+-+-+ +-+-+ +-+-+ +-+-+ +-+-+","          |   |   |   |   | |                    ","+-+-+-+-+-+-+ +-+-+-+ + +-+-+ +-+ +-+-+-+ +-+-+ +","|                     | |     |   |   | |   | | |","+ +-+-+-+-+-+-+ + +-+-+-+-+-+-+-+-+ +-+-+-+ + +-+","| |     |   | | |   | | | |       | |   | | | | |","+-+-+-+ +-+-+-+-+ +-+ + +-+ +-+-+-+ +-+-+ +-+ +-+","    | |   | "
            "| |   |               |   |          ","+-+ +-+-+-+-+-+ +-+ + +-+-+-+-+-+-+ + + +-+-+ +-+","  | | |         | | | |   |   | | | | | | | | |  ","+-+-+ + +-+ +-+ +-+-+-+-+ + + + +-+-+ +-+-+-+-+-+","    | | | | | | |         | | |       |     | |  ","+ +-+ + + +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ +-+-+","| |   | |     | |   |   |   |   |   | |         |","+-+-+ +-+-+-+-+ +-+ + +-+-+-+-+ +-+ +-+-+-+-+-+-+","      | |   | | | |     |       | |         | |  ","+-+ + +-+-+-+-+ + +-+-+-+ +-+-+-+-+ +-+ +-+-+-+-+","  | | | |   |   |     | |   |   | |   | | |   |  ","+-+-+-+-+-+-+ +-+-+-+-+-+-+ +-+ +-+ +-+ +-+-+ +-+","|     | | |   |     |     |   | | |   |   | | | |","+-+-+-+-+-+-+ + +-+-+-+-+-+ +-+-+-+-+ +-+ + +-+-+","| | | | |   | | |   | |         |     | | | |   |","+ +-+ +-+-+ + + +-+-+ + + +-+-+-+-+ +-+ +-+-+-+-+","  | | |   |     | |     |         |   | |   | | |","+ +-+ +-+-+-+ +-+-+-+-+ +-+-+-+ +-+-+-+ +-+-+ + +","|     | |     |   |           |   | | |   | | |  ","+-+-+-+-+-+-+-+ +-+-+ +-+"
                "-+-+-+-+ +-+-+ +-+-+ +-+","|         |     |       | |   |       | | | | |  ","+-+-+-+ +-+-+-+-+-+-+-+-+ +-+ +-+ +-+-+ +-+-+-+-+","        |   |   | | | | | | | | | | | | | |     |","+-+-+-+-+-+-+-+ +-+-+ +-+-+ +-+-+-+ +-+ + +-+-+ +","      | | | |       | |     | |   |       |   | |","+ +-+-+-+-+-+ +-+ +-+ +-+-+-+ +-+-+-+-+-+ + +-+-+","| | |       | | | |       |     | | | |       | |","+-+-+-+-+-+-+-+ + +-+-+-+ + +-+-+-+-+-+-+-+ +-+ +","      |   |   | |   | |         |     | | | | | |","+-+-+-+-+-+-+-+-+-+ +-+-+-+-+ +-+-+-+ + + +-+-+ +"};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        p1 = 10;
        p2 = 12;
        p3 = 160;
        all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
        // ------------------
    }

    if (all_right) {
        cout << "You're a stud (at least on the example cases)!" << endl;
    } else {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// END KAWIGIEDIT TESTING
